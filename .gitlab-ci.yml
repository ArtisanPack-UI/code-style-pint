# GitLab CI/CD Configuration for ArtisanPack UI Code Style Pint
# SAST customization: https://docs.gitlab.com/ee/user/application_security/sast/#customizing-the-sast-settings
# Secret Detection customization: https://docs.gitlab.com/ee/user/application_security/secret_detection/pipeline/#customization
# Dependency Scanning customization: https://docs.gitlab.com/ee/user/application_security/dependency_scanning/#customizing-the-dependency-scanning-settings

stages:
  - build
  - test
  - coverage
  - code-style
  - security
  - release

sast:
  stage: security

include:
  - template: Security/SAST.gitlab-ci.yml

# Build: Install Composer dependencies
build:vendors:
  stage: build
  artifacts:
    untracked: true
  only:
    refs:
      - merge_requests
      - push
  cache:
    key:
      files:
        - composer.lock
      prefix: v1
    policy: pull-push
  image: php:8.2
  before_script:
    - apt-get update -qq && apt-get install -y -qq git curl libzip-dev unzip
    - curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer
  script:
    - echo "Installing Composer dependencies..."
    - rm -rf vendor
    - composer install --no-interaction --prefer-dist --optimize-autoloader

# Unit Tests
unit-tests:
  stage: test
  dependencies:
    - build:vendors
  only:
    refs:
      - merge_requests
      - push
  cache:
    key:
      files:
        - composer.lock
      prefix: v1
    policy: pull
  image: php:8.2
  parallel: 2
  script:
    - ./vendor/bin/pest tests/Unit --ci --coverage --coverage-clover=coverage-unit.xml --parallel
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage-unit.xml
    paths:
      - coverage-unit.xml
    expire_in: 1 week

# Feature Tests
feature-tests:
  stage: test
  dependencies:
    - build:vendors
  only:
    refs:
      - merge_requests
      - push
  cache:
    key:
      files:
        - composer.lock
      prefix: v1
    policy: pull
  image: php:8.2
  script:
    - ./vendor/bin/pest tests/Feature --ci --coverage --coverage-clover=coverage-feature.xml
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage-feature.xml
    paths:
      - coverage-feature.xml
    expire_in: 1 week

# Test Coverage Analysis
coverage-analysis:
  stage: coverage
  dependencies:
    - unit-tests
    - feature-tests
  only:
    refs:
      - merge_requests
      - push
  image: php:8.2
  script:
    - ./vendor/bin/pest --coverage --coverage-html=coverage-html --coverage-clover=coverage-combined.xml --min=80
  coverage: '/^\s*Lines:\s*\d+.\d+\%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage-combined.xml
    paths:
      - coverage-html/
      - coverage-combined.xml
    expire_in: 1 week
  allow_failure: true  # Allow failures while coverage threshold is being reached

# Static Analysis
static-analysis:
  stage: code-style
  dependencies:
    - build:vendors
  only:
    refs:
      - merge_requests
      - push
  cache:
    key:
      files:
        - composer.lock
    policy: pull
  image: php:8.2
  script:
    - echo "Running PHPStan static analysis..."
    - if [ -f vendor/bin/phpstan ]; then ./vendor/bin/phpstan analyse src --level=8 --no-progress || echo "PHPStan not configured, skipping..."; fi
  allow_failure: true

# Code Style - Pint
pint:
  stage: code-style
  dependencies:
    - build:vendors
  only:
    refs:
      - merge_requests
      - push
  cache:
    key:
      files:
        - composer.lock
    policy: pull
  image: php:8.2
  script:
    - echo "Running Laravel Pint..."
    - ./vendor/bin/pint --test

# Code Style - PHPCS
phpcs:
  stage: code-style
  dependencies:
    - build:vendors
  only:
    refs:
      - merge_requests
      - push
  cache:
    key:
      files:
        - composer.lock
    policy: pull
  image: php:8.2
  script:
    - echo "Running PHPCS..."
    - if [ -f vendor/bin/phpcs ]; then ./vendor/bin/phpcs --standard=ArtisanPackUIStandard src tests || echo "PHPCS not configured, skipping..."; fi
  allow_failure: true

# Job 1: Prepare the release description from CHANGELOG.md
prepare_release_description:
  stage: release
  image: alpine:latest
  before_script:
    - apk add --no-cache grep sed bash
  rules:
    - if: $CI_COMMIT_TAG  # This job will only run when a Git tag is pushed
  script:
    - |
      set -euxo pipefail

      echo "--- Preparing Release Description ---"
      echo "CI_COMMIT_TAG: ${CI_COMMIT_TAG}"

      # Verify CHANGELOG.md exists in the current working directory
      echo "Listing files in current directory ($(pwd)):"
      ls -la
      if [ ! -f "CHANGELOG.md" ]; then
        echo "Error: CHANGELOG.md not found in the repository root. Cannot extract release description."
        RELEASE_DESCRIPTION_FINAL="Release ${CI_COMMIT_TAG}. No CHANGELOG.md found. Please create one."
      else
        echo "CHANGELOG.md found. Attempting to read content."
        echo "--- Start of CHANGELOG.md Content ---"
        cat CHANGELOG.md
        echo "--- End of CHANGELOG.md Content ---"

        # Extract the version number from the Git tag (e.g., 'v1.2.3' -> '1.2.3')
        RELEASE_VERSION=$(echo "${CI_COMMIT_TAG}" | sed 's/^v//')
        echo "Extracted RELEASE_VERSION: ${RELEASE_VERSION}"

        # Define markers for the start and end of the desired section in CHANGELOG.md
        START_MARKER="## \\[${RELEASE_VERSION}\\].*"
        END_MARKER="## \\[[^]]*\\].*"
        echo "START_MARKER: ${START_MARKER}"
        echo "END_MARKER: ${END_MARKER}"

        # Extract the block of text for the current release from CHANGELOG.md
        CHANGELOG_CONTENT=$(sed -n "/${START_MARKER}/,/${END_MARKER}/p" CHANGELOG.md)
        echo "Raw CHANGELOG_CONTENT extracted:"
        echo "${CHANGELOG_CONTENT}"

        # Clean up the extracted content
        if [ -z "${CHANGELOG_CONTENT}" ]; then
          TEMP_DESCRIPTION=""
        else
          TEMP_DESCRIPTION=$(echo "${CHANGELOG_CONTENT}" | \
            grep -v "${START_MARKER}" | \
            grep -v "${END_MARKER}" | \
            grep -v "^# Changelog" | \
            sed -e 's/^[[:space:]]*//' -e '/^$/d')
        fi

        # Fallback description if the specific version isn't found or extraction failed
        if [ -z "${TEMP_DESCRIPTION}" ] || [ "${TEMP_DESCRIPTION}" = " " ]; then
          echo "Warning: Could not find a specific description for tag ${CI_COMMIT_TAG} in CHANGELOG.md. Using a generic description."
          RELEASE_DESCRIPTION_FINAL="Release ${CI_COMMIT_TAG}. Refer to CHANGELOG.md for detailed changes."
        else
          RELEASE_DESCRIPTION_FINAL="${TEMP_DESCRIPTION}"
        fi
      fi

      echo "--- Final Release Description Content to be Passed ---"
      echo "${RELEASE_DESCRIPTION_FINAL}"
      echo "----------------------------------------------------"

      # Escape newlines in RELEASE_DESCRIPTION_FINAL for the .env file
      ESCAPED_RELEASE_DESCRIPTION=$(echo "${RELEASE_DESCRIPTION_FINAL}" | sed -E ':a;N;s/\n/\\n/g;ta')

      # Save the final escaped description to a .env file
      echo "RELEASE_DESCRIPTION=${ESCAPED_RELEASE_DESCRIPTION}" > release.env
      echo "Description saved to release.env"
  artifacts:
    reports:
      dotenv: release.env  # Export variables from release.env to subsequent jobs

# Job 2: Create the GitLab Release using the extracted description
create_actual_release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - job: prepare_release_description
      artifacts: true
  rules:
    - if: $CI_COMMIT_TAG  # Only run this job if a tag is pushed
  script:
    - |
      set -euxo pipefail
      echo "--- Creating GitLab Release ---"
      echo "CI_COMMIT_TAG: ${CI_COMMIT_TAG}"
      echo "Received RELEASE_DESCRIPTION: ${RELEASE_DESCRIPTION}"

      # Create the release using release-cli
      release-cli create --name "Release ${CI_COMMIT_TAG}" --tag-name "${CI_COMMIT_TAG}" --description "${RELEASE_DESCRIPTION}"
      echo "Release created successfully."
